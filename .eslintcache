[{"C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\reportWebVitals.js":"1","C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\App.js":"2","C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\index.js":"3","C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\TreeChart.js":"4","C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\useResizeObserver.js":"5"},{"size":362,"mtime":1608275850426,"results":"6","hashOfConfig":"7"},{"size":11727,"mtime":1609333746814,"results":"8","hashOfConfig":"7"},{"size":500,"mtime":1608275850426,"results":"9","hashOfConfig":"7"},{"size":5799,"mtime":1609330946290,"results":"10","hashOfConfig":"7"},{"size":589,"mtime":1608448915047,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"14"},"icemp0",{"filePath":"15","messages":"16","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\reportWebVitals.js",[],["26","27"],"C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\App.js",["28","29","30","31","32","33","34","35","36","37","38","39","40"],"import React, { useState, useRef } from \"react\";\nimport TreeChart from \"./TreeChart\";\nimport \"./App.css\";\n\nconst initialData = {\n  value: \"ðŸ˜\",\n  children: [\n    {\n      value: \"ðŸ™‚\",\n      children: [\n        {\n          value: \"ðŸ˜€\"\n        },\n        {\n          value: \"ðŸ˜\"\n        },\n        {\n          value: \"ðŸ¤£\"\n        }\n      ]\n    },\n    {\n      value: \"ðŸ˜”\"\n    }\n  ]\n};\n\nfunction App() {\n\n  const handleClick = () => {\n    initialData.children.push({value: \"ðŸ˜”\"});\n    setData(initialData);\n  }\n\n  const [reloadTree, setReloadTree] = useState(false);\n\n  const [numbers, setNumbers] = useState([50,17,12,23,19,9,14,72,54,67,76]);\n\n  const [paths, setPath] = useState([]);\n\n  const [traversalPath, setTraversal] = useState([]);\n\n  var curPath = [];\n\n  var curTraversal = [];\n\n  var prevNode = null;\n  \n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.children = []; // [null,null];\n      // left child: children[0], right child: children[1] \n      this.traverse = \"e\";  //TEST\n    }\n  }\n\n  class BinarySearchTree {\n    constructor(value) {\n      this.root = new Node(value);\n    }\n\n    /* insert */\n    insert(value) {\n      setReloadTree(true);\n      console.log(this);\n      // create node from value\n      var node = new Node(value);\n      // if the tree's root is null, set the root to the new node\n      if (this.root == null || this.root.value == null || this.root.value === \"e\") {\n          //console.log(\"Root is null\");\n          this.root = node;\n      }\n\n      var current = this.root;\n      while (current) {\n        // If tree contains value return\n        if (current.value == value) {\n\n          return;\n        }\n        // value is less than current.value\n        else if (value < current.value) {\n            \n          if (current.children[0] == null || current.children[0].value == \"e\") {\n            current.children[0] = node;\n            if (current.children[1]==null){\n              current.children[1] = new Node(\"e\");\n            }\n\n            return;\n          }\n          // current = current.left;\n          current = current.children[0];\n        }\n        // value is greater than current.value\n        else {\n          if (current.children[1] == null || current.children[1].value == \"e\") {\n            // if (current.children[1] == null ){\n            if (!current.children[0]) {\n              current.children[0] = new Node(\"e\");\n            }\n            current.children[1] = node;\n\n            return;\n            }\n          current = current.children[1];\n        }\n      }\n    }\n\n    findMinNode(node) \n    { \n      // if left of a node is null \n      // then it must be minimum node \n      if(node.children[0] === \"null\" || node.children.length === 0 || node.children[0].value === \"e\"){\n        console.log(\"ITO YUNG MIN NODE\");\n        console.log(node);\n        return node; \n      }\n      else\n        return this.findMinNode(node.children[0]); \n    } \n\n    remove(data) \n    { \n      this.root = this.removeNode(this.root, data); \n      console.log(this);\n    } \n  \n    // Method to remove node with a  \n    // given data \n    // it recur over the tree to find the \n    // data and removes it \n    removeNode(node, key) \n    { \n      // if the root is null then tree is  \n      // empty \n\n      // if(typeof(node) == \"undefined\") {\n      //     return; \n      // }\n    \n      // if data to be delete is less than  \n      // roots data then move to left subtree \n      if(key < node.value) \n      { \n        if(typeof(node.children[0]) == \"undefined\") {\n          return node;\n        }\n\n        node.children[0] = this.removeNode(node.children[0], key); \n        return node; \n      } \n    \n      // if data to be delete is greater than  \n      // roots data then move to right subtree \n      else if(key > node.value) \n      { \n        if(typeof(node.children[1]) == \"undefined\") {\n          return node;\n        }\n\n        node.children[1] = this.removeNode(node.children[1], key); \n        return node; \n      } \n    \n      else\n      { \n        console.log(node);\n\n        if((node.children.length === 0) || (node.children[0].value === \"e\" && node.children[1].value === \"e\")) \n        { \n\n          console.log(\"BOTH NULL\");\n          node.value = \"e\"; \n          node.children.length = 0;\n          return node; \n        } \n  \n        // deleting node with one children \n        if(node.children[0] === null || node.children[0].value === \"e\") \n        { \n          console.log(\"LEFT CHILD YUNG NULL\");\n            node = node.children[1]; \n            return node; \n        } \n          \n        else if(node.children[1] === null || node.children[1].value === \"e\") \n        { \n          console.log(\"RIGHT CHILD YUNG NULL\");\n          node = node.children[0]; \n          return node; \n        } \n  \n        // Deleting node with two children \n        // minumum node of the rigt subtree \n        // is stored in aux \n        var aux = this.findMinNode(node.children[1]); \n        node.value = aux.value; \n  \n        node.children[1] = this.removeNode(node.children[1], aux.value); \n        return node; \n      } \n    }\n\n    search(data) \n    { \n      curPath = [];\n      setPath([]);\n      this.searchNode(this.root, data); \n      console.log(this);\n    } \n  \n    // Method to remove node with a  \n    // given data \n    // it recur over the tree to find the \n    // data and removes it \n\n\n    searchNode(node, key) \n    { \n      console.log(node.value);    \n      // if the root is null then tree is  \n      // empty \n      // if(node === \"null\") \n      //     return null; \n    \n      // if data to be delete is less than  \n      // roots data then move to left subtree \n      if(key < node.value) \n      { \n        curPath.push(node.value);\n        setPath([curPath]);\n\n        if(typeof(node.children[0]) == \"undefined\") {\n          setPath([]);\n          return;\n        }\n\n        this.searchNode(node.children[0], key); \n        return; \n      } \n    \n      else if(key > node.value) \n      { \n        curPath.push(node.value);\n        setPath([curPath]);\n\n        if(typeof(node.children[1]) == \"undefined\") {\n          setPath([]);\n          return;\n        }\n\n        this.searchNode(node.children[1], key); \n        return; \n      } \n\n      else\n      { \n        curPath.push(node.value);\n        console.log(curPath);\n        setPath([curPath]);\n      }\n    } \n\n    inOrder() {\n      setTraversal([]);\n      curTraversal = [];\n\n      this.inOrderHelper(this.root);\n      console.log(curTraversal);\n      curTraversal.pop();\n      \n      setTraversal(curTraversal);\n    }\n\n    inOrderHelper(root) {\n      if (typeof(root) != \"undefined\") {\n        if (root.value != \"e\"){\n          this.inOrderHelper(root.children[0]);\n\n          console.log(root.value);\n          curTraversal.push(root);\n          setTraversal([curTraversal]);\n\n          if(prevNode == null){\n            prevNode = root;\n          }\n          else {\n            prevNode.traverse = root;\n            prevNode = root;\n          }\n\n          this.inOrderHelper(root.children[1]);\n        }\n      }\n    }\n\n    preOrder() {\n      setTraversal([]);\n      curTraversal = [];\n\n      this.preOrderHelper(this.root);\n      console.log(curTraversal);\n      curTraversal.pop();\n      \n      setTraversal(curTraversal);\n    }\n\n    preOrderHelper(root) {\n      if (typeof(root) != \"undefined\") {\n        if (root.value != \"e\"){\n\n          console.log(root.value);\n          curTraversal.push(root);\n          setTraversal([curTraversal]);\n\n          if(prevNode == null){\n            prevNode = root;\n          }\n          else {\n            prevNode.traverse = root;\n            prevNode = root;\n          }\n\n          this.preOrderHelper(root.children[0]);\n\n          this.preOrderHelper(root.children[1]);\n        }\n      }\n    }\n\n    postOrder() {\n      setTraversal([]);\n      curTraversal = [];\n\n      this.postOrderHelper(this.root);\n      console.log(curTraversal);\n      curTraversal.pop();\n      \n      setTraversal(curTraversal);\n    }\n\n    postOrderHelper(root) {\n      if (typeof(root) != \"undefined\") {\n        if (root.value != \"e\"){\n\n          this.postOrderHelper(root.children[0]);\n\n          this.postOrderHelper(root.children[1]);\n\n          console.log(root.value);\n          curTraversal.push(root);\n          setTraversal([curTraversal]);\n\n          if(prevNode == null){\n            prevNode = root;\n          }\n          else {\n            prevNode.traverse = root;\n            prevNode = root;\n          }\n\n        }\n      }\n    }\n  } \n\n  const [constructor, setConstructor] = useState(false);\n\n  if(constructor === false){\n    console.log(constructor);\n    setConstructor(true);\n    var tree = new BinarySearchTree(null);\n  }\n\n  //const tree = new BinarySearchTree(null);\n\n\n  const [data, setData] = useState(new BinarySearchTree(null));\n\n  const [, updateState] = React.useState();\n  const forceUpdate = React.useCallback(() => updateState({}), []);\n\n \n\n  \n\n  const doOperation = () => {\n    // for (var i = 0; i < numbers.length; i++) {\n    //   tree.insert(numbers[i]);\n    // }\n\n    //console.log(paths);\n  }\n\n  const [numToInsert, setnumInsert] = useState(\"\");\n\n  const [numToDelete, setnumDelete] = useState(\"\");\n\n  const [numToSearch, setnumSearch] = useState(\"\");\n\n  const handleSubmitInsertion = (e) => {\n    setTraversal([]);\n    setPath([]);\n    e.preventDefault();\n\n    var tree = data;\n    console.log(tree);\n    tree.insert(parseInt(numToInsert));\n    setData(tree);\n  }\n\n  const handleSubmitDeletion = (e) => {\n    setTraversal([]);\n    setPath([]);\n    e.preventDefault();\n\n    setReloadTree(true);\n\n    var tree = data;\n    tree.remove(parseInt(numToDelete));\n    setData(tree);\n  }\n\n  const handleSubmitSearch = (e) => {\n    e.preventDefault();\n    setPath([]);\n    setTraversal([]);\n\n    setReloadTree(true);\n\n    var tree = data;\n    console.log(tree);\n    tree.search(parseInt(numToSearch));\n    console.log(tree);\n  }\n\n\n  return (\n    <React.Fragment>\n      <div className = \"controls\">\n        <h1>Binary Search Tree Visualizer</h1>\n\n        <form onSubmit = {handleSubmitInsertion}>\n          <input type = \"text\" value = {numToInsert} required onChange = {(e) => {setnumInsert(e.target.value); setReloadTree(false);}} />\n          <input type = \"submit\" value = \"Add number\" />\n        </form>\n\n        <form onSubmit = {handleSubmitDeletion}>\n          <input type = \"text\" value = {numToDelete} required onChange = {(e) => {setnumDelete(e.target.value); setReloadTree(false);}} />\n          <input type = \"submit\" value = \"Delete number\" />\n        </form>\n\n        <form onSubmit = {handleSubmitSearch}>\n          <input type = \"text\" value = {numToSearch} required onChange = {(e) => {setnumSearch(e.target.value); setReloadTree(false);}} />\n          <input type = \"submit\" value = \"Search number\" />\n        </form>\n\n        <button onClick = {() => setPath([])} className = \"reset_button\">\n          Reset Search Path\n        </button>\n\n        <div>\n          <button onClick = {() => {data.inOrder(); setReloadTree(false);}}>\n            Inorder Traversal\n          </button>\n\n          <button onClick = {() => {data.preOrder(); setReloadTree(false);}}>\n            Preorder Traversal\n          </button>\n\n          <button onClick = {() => {data.postOrder(); setReloadTree(false);}}>\n            Postoder Traversal\n          </button>\n\n          <button onClick = {() => setTraversal([])} className = \"reset_button\">\n            Reset Traversal Path\n          </button>\n        </div>\n      </div>\n\n      <br/><br/>\n      <TreeChart className = \"tree\" data={data} pathData = {paths} traversalData = {traversalPath} reloadData = {reloadTree}/>\n\n\n    </React.Fragment>\n  );\n}\n\nexport default App;\n","C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\index.js",[],["41","42"],"C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\TreeChart.js",["43","44","45","46","47","48","49"],"import React, { useRef, useEffect } from \"react\";\nimport { select, hierarchy, tree, linkHorizontal } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\n\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nfunction TreeChart({ data, pathData, traversalData, reloadData }) {\n  const svgRef = useRef();\n  const wrapperRef = useRef();\n  const dimensions = useResizeObserver(wrapperRef);\n\n  pathData = pathData.flat();\n\n  // we save data to see if it changed\n  const previouslyRenderedData = usePrevious(data);\n\n  data = data.root;\n\n  // will be called initially and on every data change\n  useEffect(() => {\n    const svg = select(svgRef.current);\n\n    // use dimensions from useResizeObserver,\n    // but use getBoundingClientRect on initial render\n    // (dimensions are null for the first render)\n    const { width, height } =\n      dimensions || wrapperRef.current.getBoundingClientRect();\n\n    // transform hierarchical data\n    const root = hierarchy(data);\n    const treeLayout = tree().size([width, height * 2]);\n\n    const linkGenerator = linkHorizontal()\n      .x(link => link.x)\n      .y(link => link.y);\n\n    const linkGenerator2 = (source, target) => {\n      return \"M \" + source.x + \" \" + source.y +\n      \" L \" + target.x + \" \" + target.y;\n    }\n\n    // enrich hierarchical data with coordinates\n    treeLayout(root);\n\n    console.warn(\"descendants\", root.descendants());\n    console.warn(\"links\", root.links());\n    console.warn(\"path data\", pathData.flat());\n    console.warn(\"traversal data\", traversalData);\n    console.warn(\"tree reload\", reloadData);\n\n    // nodes\n    svg\n      .selectAll(\".node\")\n      .data(root.descendants())\n      .join(enter => enter.append(\"circle\").attr(\"opacity\", 0))\n      .attr(\"class\", \"node\")\n      .attr(\"cx\", node => node.x)\n      .attr(\"cy\", node => node.y)\n      .attr(\"r\", function(d) {\n        if (d.data.value === \"e\") {\n          return 3;\n        }\n        // if(pathData.includes(d.data.value)){\n        //   return 15;\n        // }\n        return 6;\n      })   \n      .attr(\"fill\", function(d) { //TO SHOW PATH \n        if(pathData.includes(d.data.value)){\n          return \"#21c712\";\n        }\n        return \"#80c4ff\";\n      }) \n      .attr(\"stroke-width\", 0)\n      .transition()\n      .duration(500)\n      .delay(node => node.depth * 300)\n      .attr(\"opacity\", 1);\n\n    // links\n    const enteringAndUpdatingLinks = svg\n      .selectAll(\".link\")\n      .data(root.links())\n      .join(\"path\")\n      .attr(\"class\", \"link\")\n      .attr(\"d\", linkGenerator)\n      .attr(\"stroke-dasharray\", function() {\n        const length = this.getTotalLength();\n        return `${length} ${length}`;\n      })\n      .attr(\"stroke\", function(d) { //TO SHOW PATH \n        if(pathData.includes(d.target.data.value)){\n          return \"#21c712\";\n        }\n        return \"#80c4ff\";\n      }) \n      .attr(\"stroke-width\", function(d) {\n        if (d.target.data.value === \"e\") {\n          return 1;\n        }\n        if (d.target.data.state === \"path\") {\n          return 10;\n        }\n        return 4;\n      })\n      .attr(\"fill\", \"none\")\n      .attr(\"opacity\", 1);\n\n    if (reloadData === true) {\n      enteringAndUpdatingLinks\n        .attr(\"stroke-dashoffset\", function() {\n          return this.getTotalLength();\n        })\n        .transition()\n        .duration(500)\n        .delay(link => link.source.depth * 500)\n        .attr(\"stroke-dashoffset\", 0);\n    }\n\n    // labels\n    svg\n      .selectAll(\".label\")\n      .data(root.descendants())\n      .join(enter => enter.append(\"text\").attr(\"opacity\", 0))\n      .attr(\"class\", \"label\")\n      .attr(\"x\", node => node.x)\n      .attr(\"y\", node => node.y - 12)\n      .attr(\"text-anchor\", \"middle\")\n      .attr(\"font-size\", 24)\n      .attr(\"fill\", \"white\")\n      .text(function(d) {\n        if (d.data.value === \"e\") {\n          return \"\";\n        }\n        return d.data.value;\n      })\n      .transition()\n      .duration(500)\n      .delay(node => node.depth * 300)\n      .attr(\"opacity\", 1);\n\n    //arrow test\n    svg.append(\"svg:defs\").append(\"svg:marker\")\n      .attr(\"id\", \"arrow\")\n      .attr(\"refX\", 6)\n      .attr(\"refY\", 6)\n      .attr(\"markerWidth\", 12)\n      .attr(\"markerHeight\", 12)\n      .attr(\"orient\", \"auto\")\n      .attr(\"viewBox\", \"0 0 12 12\")\n      .append(\"path\")\n      .attr(\"d\", \"M2,2 L10,6 L2,10 L6,6 L2,2\")\n      .style(\"fill\", \"#fff000\");\n\n    svg\n      .selectAll(\".traversal\")\n      .data(traversalData)\n      .join(enter => enter.append(\"line\"))\n      .attr(\"class\", \"traversal\")\n      .attr(\"x1\", function(d) { var des = root.descendants(); return des[des.findIndex(node => node.data.value == d.value)].x })\n      .attr(\"y1\", function(d) { var des = root.descendants(); return des[des.findIndex(node => node.data.value == d.value)].y })\n      .attr(\"x2\", function(d) { var des = root.descendants(); return des[des.findIndex(node => node.data.value == d.traverse.value)].x })\n      .attr(\"y2\", function(d) { var des = root.descendants(); return des[des.findIndex(node => node.data.value == d.traverse.value)].y })\n      .attr(\"stroke\", function(d) {\n        var des = root.descendants();\n        console.log(\"STROKE LOGS\");\n        console.log(d);\n        console.log(des[des.findIndex(node => node.data.value == d.value)]);\n        console.log(des[des.findIndex(node => node.data.value == d.traverse.value)]);\n        return \"red\"\n      })\n      .attr(\"stroke\",\"#fff000\")  \n      .attr(\"stroke-width\",2)  \n      .attr(\"marker-end\",\"url(#arrow)\"); \n      \n  }, [data, pathData, traversalData, dimensions, reloadData, previouslyRenderedData]);\n\n  return (\n    <div ref={wrapperRef} style={{ marginBottom: \"2rem\" }}>\n      <svg ref={svgRef}></svg>\n    </div>\n  );\n}\n\nexport default TreeChart;\n","C:\\Users\\VON\\Documents\\React Files\\d3Test\\d3_react_app\\src\\useResizeObserver.js",[],{"ruleId":"50","replacedBy":"51"},{"ruleId":"52","replacedBy":"53"},{"ruleId":"54","severity":1,"message":"55","line":1,"column":27,"nodeType":"56","messageId":"57","endLine":1,"endColumn":33},{"ruleId":"54","severity":1,"message":"58","line":30,"column":9,"nodeType":"56","messageId":"57","endLine":30,"endColumn":20},{"ruleId":"54","severity":1,"message":"59","line":37,"column":10,"nodeType":"56","messageId":"57","endLine":37,"endColumn":17},{"ruleId":"54","severity":1,"message":"60","line":37,"column":19,"nodeType":"56","messageId":"57","endLine":37,"endColumn":29},{"ruleId":"61","severity":1,"message":"62","line":78,"column":27,"nodeType":"63","messageId":"64","endLine":78,"endColumn":29},{"ruleId":"61","severity":1,"message":"62","line":85,"column":72,"nodeType":"63","messageId":"64","endLine":85,"endColumn":74},{"ruleId":"61","severity":1,"message":"62","line":98,"column":72,"nodeType":"63","messageId":"64","endLine":98,"endColumn":74},{"ruleId":"61","severity":1,"message":"65","line":280,"column":24,"nodeType":"63","messageId":"64","endLine":280,"endColumn":26},{"ruleId":"61","severity":1,"message":"65","line":313,"column":24,"nodeType":"63","messageId":"64","endLine":313,"endColumn":26},{"ruleId":"61","severity":1,"message":"65","line":347,"column":24,"nodeType":"63","messageId":"64","endLine":347,"endColumn":26},{"ruleId":"54","severity":1,"message":"66","line":375,"column":9,"nodeType":"56","messageId":"57","endLine":375,"endColumn":13},{"ruleId":"54","severity":1,"message":"67","line":384,"column":9,"nodeType":"56","messageId":"57","endLine":384,"endColumn":20},{"ruleId":"54","severity":1,"message":"68","line":390,"column":9,"nodeType":"56","messageId":"57","endLine":390,"endColumn":20},{"ruleId":"50","replacedBy":"69"},{"ruleId":"52","replacedBy":"70"},{"ruleId":"54","severity":1,"message":"71","line":43,"column":11,"nodeType":"56","messageId":"57","endLine":43,"endColumn":25},{"ruleId":"61","severity":1,"message":"62","line":166,"column":112,"nodeType":"63","messageId":"64","endLine":166,"endColumn":114},{"ruleId":"61","severity":1,"message":"62","line":167,"column":112,"nodeType":"63","messageId":"64","endLine":167,"endColumn":114},{"ruleId":"61","severity":1,"message":"62","line":168,"column":112,"nodeType":"63","messageId":"64","endLine":168,"endColumn":114},{"ruleId":"61","severity":1,"message":"62","line":169,"column":112,"nodeType":"63","messageId":"64","endLine":169,"endColumn":114},{"ruleId":"61","severity":1,"message":"62","line":174,"column":63,"nodeType":"63","messageId":"64","endLine":174,"endColumn":65},{"ruleId":"61","severity":1,"message":"62","line":175,"column":63,"nodeType":"63","messageId":"64","endLine":175,"endColumn":65},"no-native-reassign",["72"],"no-negated-in-lhs",["73"],"no-unused-vars","'useRef' is defined but never used.","Identifier","unusedVar","'handleClick' is assigned a value but never used.","'numbers' is assigned a value but never used.","'setNumbers' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'tree' is assigned a value but never used.","'forceUpdate' is assigned a value but never used.","'doOperation' is assigned a value but never used.",["72"],["73"],"'linkGenerator2' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]